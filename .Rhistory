if (!quiet) {
message(paste0("Reprojected ", infile, " from EPSG:", inEPSG, " to EPSG:", outEPSG))
}
}
folder <- "D:/T3_AirborneLidar/WA_SP_SOUTH"
tiles <- Sys.glob(file.path(folder, "*.laz"))
# make new file names with "UTM10" in them
outtiles <- str_replace(tiles, "WA_SP_SOUTH", "UTM10")
outtiles[1]
# make new file names with "UTM10" in them
outtiles <- str_replace(tiles, "WA_SP_SOUTH", "TEST")
outtiles[1]
i <- 1
LASreproject(tiles[i], outtiles[i], 2927, 26910, to_meter)
>sf::crs
?sf::crs
?CRS
?crs``
?crs
?spTransform
LASreproject <- function(
infile,
outfile,
inEPSG,
outEPSG,
Zfactor = 1.0,
quiet = FALSE
) {
las <- readLAS(infile)
# copy header
hd = las@header
# convert to simple spatial points data frame
las = as.spatial(las)
# force projection...ensures a "correct" string
proj4string(las) <- CRS(paste0("EPSG:", inEPSG))
# reproject
las = spTransform(las, CRS(paste0("EPSG:", outEPSG)))
# convert elevations
if (Zfactor != 1.0) las@data$Z <- las@data$Z * Zfactor
# rebuild the spatial points data frame
las = cbind(las@coords, las@data)
# rebuild the LAS object
las = LAS(data=las, header=hd)
# force projection
las@crs <- sp::CRS(paste0("EPSG:", outEPSG))
# write data
writeLAS(las, outfile)
if (!quiet) {
message(paste0("Reprojected ", infile, " from EPSG:", inEPSG, " to EPSG:", outEPSG))
}
}
folder <- "D:/T3_AirborneLidar/TEST"
tiles <- Sys.glob(file.path(folder, "*.laz"))
# make new file names with "UTM10" in them
outtiles <- str_replace(tiles, "008", "008_WASP")
# reproject files from WA state plane South to UTM zone 10 and convert elevations from us-feet to meters
for (i in 1:length(tiles)) {
LASreproject(tiles[i], outtiles[i], 26910, 2927, 1/to_meter)
}
LASreproject <- function(
infile,
outfile,
inEPSG,
outEPSG,
Zfactor = 1.0,
quiet = FALSE
) {
las <- readLAS(infile)
# copy header
hd = las@header
# convert to simple spatial points data frame
las = as.spatial(las)
# force projection...ensures a "correct" string
proj4string(las) <- CRS(paste0("EPSG:", inEPSG))
# reproject
las = spTransform(las, CRS(paste0("EPSG:", outEPSG)))
# convert elevations
if (Zfactor != 1.0) las@data$Z <- las@data$Z * Zfactor
# rebuild the spatial points data frame
las = cbind(las@coords, las@data)
# rebuild the LAS object
las = LAS(data=las, header=hd)
# force projection
epsg(las@header) <- outEPSG
#las@crs <- sp::CRS(paste0("EPSG:", outEPSG))
# write data
writeLAS(las, outfile)
if (!quiet) {
message(paste0("Reprojected ", infile, " from EPSG:", inEPSG, " to EPSG:", outEPSG))
}
}
# reproject files from WA state plane South to UTM zone 10 and convert elevations from us-feet to meters
for (i in 1:length(tiles)) {
LASreproject(tiles[i], outtiles[i], 26910, 2927, 1/to_meter)
}
?epsg
LASreproject <- function(
infile,
outfile,
inEPSG,
outEPSG,
Zfactor = 1.0,
quiet = FALSE
) {
las <- readLAS(infile)
# copy header
hd = las@header
# convert to simple spatial points data frame
las = as.spatial(las)
# force projection...ensures a "correct" string
proj4string(las) <- CRS(paste0("EPSG:", inEPSG))
# reproject
las = spTransform(las, CRS(paste0("EPSG:", outEPSG)))
# convert elevations
if (Zfactor != 1.0) las@data$Z <- las@data$Z * Zfactor
# rebuild the spatial points data frame
las = cbind(las@coords, las@data)
# rebuild the LAS object
las = LAS(data=las, header=hd)
# force projection
epsg(las) <- outEPSG
#las@crs <- sp::CRS(paste0("EPSG:", outEPSG))
# write data
writeLAS(las, outfile)
if (!quiet) {
message(paste0("Reprojected ", infile, " from EPSG:", inEPSG, " to EPSG:", outEPSG))
}
}
# reproject files from WA state plane South to UTM zone 10 and convert elevations from us-feet to meters
for (i in 1:length(tiles)) {
LASreproject(tiles[i], outtiles[i], 26910, 2927, 1/to_meter)
}
LASreproject <- function(
infile,
outfile,
inEPSG,
outEPSG,
Zfactor = 1.0,
quiet = FALSE
) {
las <- readLAS(infile)
# copy header
hd = las@header
# convert to simple spatial points data frame
las = as.spatial(las)
# force projection...ensures a "correct" string
proj4string(las) <- CRS(paste0("EPSG:", inEPSG))
# reproject
las = spTransform(las, CRS(paste0("EPSG:", outEPSG)))
# convert elevations
if (Zfactor != 1.0) las@data$Z <- las@data$Z * Zfactor
# rebuild the spatial points data frame
las = cbind(las@coords, las@data)
# rebuild the LAS object
las = LAS(data=las, header=hd)
# force projection
st_crs(las) <- outEPSG
#las@crs <- sp::CRS(paste0("EPSG:", outEPSG))
# write data
writeLAS(las, outfile)
if (!quiet) {
message(paste0("Reprojected ", infile, " from EPSG:", inEPSG, " to EPSG:", outEPSG))
}
}
# reproject files from WA state plane South to UTM zone 10 and convert elevations from us-feet to meters
for (i in 1:length(tiles)) {
LASreproject(tiles[i], outtiles[i], 26910, 2927, 1/to_meter)
}
LASreproject <- function(
infile,
outfile,
inEPSG,
outEPSG,
Zfactor = 1.0,
quiet = FALSE
) {
las <- readLAS(infile)
# copy header
hd = las@header
# convert to simple spatial points data frame
las = as.spatial(las)
# force projection...ensures a "correct" string
# force projection...just overwrites projection info and e nsures a good crs string
st_crs(las) <- inEPSG
# reproject
las = spTransform(las, CRS(paste0("EPSG:", outEPSG)))
# convert elevations
if (Zfactor != 1.0) las@data$Z <- las@data$Z * Zfactor
# rebuild the spatial points data frame
las = cbind(las@coords, las@data)
# rebuild the LAS object
las = LAS(data=las, header=hd)
# force projection...just overwrites projection info
st_crs(las) <- outEPSG
# write data
writeLAS(las, outfile)
if (!quiet) {
message(paste0("Reprojected ", infile, " from EPSG:", inEPSG, " to EPSG:", outEPSG))
}
}
# reproject files from WA state plane South to UTM zone 10 and convert elevations from us-feet to meters
for (i in 1:length(tiles)) {
LASreproject(tiles[i], outtiles[i], 26910, 2927, 1/to_meter)
}
?proj4string
LASreproject <- function(
infile,
outfile,
inEPSG,
outEPSG,
Zfactor = 1.0,
quiet = FALSE
) {
las <- readLAS(infile)
# copy header
hd = las@header
# convert to simple spatial points data frame
las = as.spatial(las)
# force projection...ensures a "correct" string
# force projection...just overwrites projection info and e nsures a good crs string
proj4string(las) <- CRS(paste0("EPSG:", inEPSG))
# reproject
las = spTransform(las, CRS(paste0("EPSG:", outEPSG)))
# convert elevations
if (Zfactor != 1.0) las@data$Z <- las@data$Z * Zfactor
# rebuild the spatial points data frame
las = cbind(las@coords, las@data)
# rebuild the LAS object
las = LAS(data=las, header=hd)
# force projection...just overwrites projection info
st_crs(las) <- outEPSG
# write data
writeLAS(las, outfile)
if (!quiet) {
message(paste0("Reprojected ", infile, " from EPSG:", inEPSG, " to EPSG:", outEPSG))
}
}
# reproject files from WA state plane South to UTM zone 10 and convert elevations from us-feet to meters
for (i in 1:length(tiles)) {
LASreproject(tiles[i], outtiles[i], 26910, 2927, 1/to_meter)
}
write.csv(fTrees, file = paste0(outputFolder, "/FUSIONFieldLocations_Plot_", plotsWithTrees[i], ".csv"), row.names = FALSE, quote = TRUE)
?AffineTransformation
aft = SimilarityTransformation(controlPts)
calculateParameters(aft)
tp <- getParameters(aft)
getResiduals(aft)
getRMSE(aft)
# vec2dtransf package as a function to apply the affine transformation but it only works with sp objects
# we can use the return values from getParameters(aft) to apply the transformation using:
# x' = ax + by + c
# y' = dx + ey + f
#
# However, we want to adjust all of the trees on the plot, not just those used for computing the transformation
allpTrees$AdjXfield <- tp["a"] * allpTrees$Xfield + tp["b"] * allpTrees$Yfield + tp["c"]
allpTrees$AdjYfield <- tp["d"] * allpTrees$Xfield + tp["e"] * allpTrees$Yfield + tp["f"]
adjfTrees <- makeAdjustedFUSIONTrees(allpTrees, R = 0, G = 255, B = 0)
write.csv(adjfTrees, file = paste0(outputFolder, "/AdjustedFUSIONFieldLocations_Plot_", plotsWithTrees[i], ".csv"), row.names = FALSE, quote = TRUE)
tp
allpTrees$AdjXfield <- tp["a"] * allpTrees$Xfield + tp["b"] * allpTrees$Yfield + tp["c"]
allpTrees$AdjYfield <- tp["a"] * allpTrees$Yfield - tp["b"] * allpTrees$Xfield + tp["d"]
adjfTrees <- makeAdjustedFUSIONTrees(allpTrees, R = 0, G = 255, B = 0)
write.csv(adjfTrees, file = paste0(outputFolder, "/AdjustedFUSIONFieldLocations_Plot_", plotsWithTrees[i], ".csv"), row.names = FALSE, quote = TRUE)
t <- "affine"
if (t == "affine") {
aft = AffineTransformation(controlPts)
calculateParameters(aft)
atp <- getParameters(aft)
getResiduals(aft)
getRMSE(aft)
# we can use the return values from getParameters(aft) to apply the transformation using:
# x' = ax + by + c
# y' = dx + ey + f
#
allpTrees$AdjXfield <- atp["a"] * allpTrees$Xfield + atp["b"] * allpTrees$Yfield + atp["c"]
allpTrees$AdjYfield <- atp["d"] * allpTrees$Xfield + atp["e"] * allpTrees$Yfield + atp["f"]
} else {
sft = SimilarityTransformation(controlPts)
calculateParameters(sft)
stp <- getParameters(sft)
getResiduals(sft)
getRMSE(sft)
# for a similarity transformation the equations are:
# x' = ax + by + c
# y' = ay - bx + d
# similarity transformation
allpTrees$AdjXfield <- stp["a"] * allpTrees$Xfield + stp["b"] * allpTrees$Yfield + stp["c"]
allpTrees$AdjYfield <- stp["a"] * allpTrees$Yfield - stp["b"] * allpTrees$Xfield + stp["d"]
}
adjfTrees <- makeAdjustedFUSIONTrees(allpTrees, R = 0, G = 255, B = 0)
write.csv(adjfTrees, file = paste0(outputFolder, "/AdjustedFUSIONFieldLocations_Plot_", plotsWithTrees[i], "_", t, ".csv"), row.names = FALSE, quote = TRUE)
t <- "similarity"
if (t == "affine") {
aft = AffineTransformation(controlPts)
calculateParameters(aft)
atp <- getParameters(aft)
getResiduals(aft)
getRMSE(aft)
# we can use the return values from getParameters(aft) to apply the transformation using:
# x' = ax + by + c
# y' = dx + ey + f
#
allpTrees$AdjXfield <- atp["a"] * allpTrees$Xfield + atp["b"] * allpTrees$Yfield + atp["c"]
allpTrees$AdjYfield <- atp["d"] * allpTrees$Xfield + atp["e"] * allpTrees$Yfield + atp["f"]
} else {
sft = SimilarityTransformation(controlPts)
calculateParameters(sft)
stp <- getParameters(sft)
getResiduals(sft)
getRMSE(sft)
# for a similarity transformation the equations are:
# x' = ax + by + c
# y' = ay - bx + d
# similarity transformation
allpTrees$AdjXfield <- stp["a"] * allpTrees$Xfield + stp["b"] * allpTrees$Yfield + stp["c"]
allpTrees$AdjYfield <- stp["a"] * allpTrees$Yfield - stp["b"] * allpTrees$Xfield + stp["d"]
}
adjfTrees <- makeAdjustedFUSIONTrees(allpTrees, R = 0, G = 255, B = 0)
write.csv(adjfTrees, file = paste0(outputFolder, "/AdjustedFUSIONFieldLocations_Plot_", plotsWithTrees[i], "_", t, ".csv"), row.names = FALSE, quote = TRUE)
outputFolder <- "E:/Backup/R_Stuff/ONRCDroneLidar"
combinedTrees <- read.csv(file = paste0(outputFolder, "/FieldTrees.csv"), stringsAsFactors = FALSE)
# predict height using custom T3 equations
for (i in 1:nrow(combinedTrees)) {
combinedTrees$T3Ht[i] <- predictHeight(combinedTrees$Species[i], combinedTrees$DBH_cm[i], method = "customT3", DBHUnits = "cm", heightUnits = "meters")
}
# filter for species, anomaly codes and field call on whether or not tree is visible from above
other <- dplyr::filter(combinedTrees, (Species != "PSME" & Species != "TSHE") | Anomaly1 != 0 | LiDAR_visible != "Y")
psme <- dplyr::filter(combinedTrees, Species == "PSME", Anomaly1 == 0, LiDAR_visible == "Y")
tshe <- dplyr::filter(combinedTrees, Species == "TSHE", Anomaly1 == 0, LiDAR_visible == "Y")
# psme and tshe are the candidate trees for matching to lidar TAOs
candidates <- rbind(psme, tshe)
# # predict height using custom T3 equations
# for (i in 1:nrow(candidates)) {
#   candidates$T3Ht[i] <- predictHeight(candidates$Species[i], candidates$DBH_cm[i], method = "customT3", DBHUnits = "cm", heightUnits = "meters")
# }
plotsWithTrees <- unique(candidates$Plot_Number)
outputFolder <- "G:/R_Stuff/ONRCDroneLidar/Adjustments"
# create FUSION tree files for the field measured trees
for (i in 1:length(plotsWithTrees)) {
#  i = 1
# create FUSION tree files for the TAO objects that will be used for matching
pTrees <- candidates[candidates$Plot_Number == plotsWithTrees[i],]
fTrees <- makeFUSIONTrees(pTrees, R = 255, G = 0, B = 255)
# get all trees for plot...needed to apply the adjustment
allpTrees <- combinedTrees[combinedTrees$Plot_Number == plotsWithTrees[i],]
write.csv(fTrees, file = paste0(outputFolder, "/FUSIONFieldLocations_Plot_", plotsWithTrees[i], ".csv"), row.names = FALSE, quote = TRUE)
}
library(dplyr)
library(vec2dtransf)
source("Rcode/predictDBH_Height.R")
makeFUSIONTrees <- function(x, R = 0, G = 192, B = 0, statusCode = 0) {
FUSIONtrees <- data.frame(
"TreeID" = x$TreeID,
"X" = x$Xfield,
"Y" = x$Yfield,
"Elevation" = 0.0,
"Height_m" = x$T3Ht,
"CBH_m" = x$T3Ht * 0.6,
"MinCrownDia_m" = x$T3Ht * 0.16,
"MaxCrownDia_m" = x$T3Ht * 0.16,
"rotation" = 0.0,
"R" = R,
"G" = G,
"B" = B,
"DBH_m" = x$DBH_cm / 100,
"LeanFromVertical" = 0,
"LeanAzimuth" = 0,
"StatusCode" = statusCode
)
return(invisible(FUSIONtrees))
}
makeAdjustedFUSIONTrees <- function(x, R = 0, G = 192, B = 0, statusCode = 0) {
FUSIONtrees <- data.frame(
"TreeID" = x$TreeID,
"X" = x$AdjXfield,
"Y" = x$AdjYfield,
"Elevation" = 0.0,
"Height_m" = x$T3Ht,
"CBH_m" = x$T3Ht * 0.6,
"MinCrownDia_m" = x$T3Ht * 0.16,
"MaxCrownDia_m" = x$T3Ht * 0.16,
"rotation" = 0.0,
"R" = R,
"G" = G,
"B" = B,
"DBH_m" = x$DBH_cm / 100,
"LeanFromVertical" = 0,
"LeanAzimuth" = 0,
"StatusCode" = statusCode
)
return(invisible(FUSIONtrees))
}
# *****************************************************************************
# *****************************************************************************
# read field trees and filter to just PSME and TSHE and only trees visible
# to lidar
# *****************************************************************************
# *****************************************************************************
outputFolder <- "E:/Backup/R_Stuff/ONRCDroneLidar"
combinedTrees <- read.csv(file = paste0(outputFolder, "/FieldTrees.csv"), stringsAsFactors = FALSE)
# predict height using custom T3 equations
for (i in 1:nrow(combinedTrees)) {
combinedTrees$T3Ht[i] <- predictHeight(combinedTrees$Species[i], combinedTrees$DBH_cm[i], method = "customT3", DBHUnits = "cm", heightUnits = "meters")
}
# filter for species, anomaly codes and field call on whether or not tree is visible from above
other <- dplyr::filter(combinedTrees, (Species != "PSME" & Species != "TSHE") | Anomaly1 != 0 | LiDAR_visible != "Y")
psme <- dplyr::filter(combinedTrees, Species == "PSME", Anomaly1 == 0, LiDAR_visible == "Y")
tshe <- dplyr::filter(combinedTrees, Species == "TSHE", Anomaly1 == 0, LiDAR_visible == "Y")
# psme and tshe are the candidate trees for matching to lidar TAOs
candidates <- rbind(psme, tshe)
# # predict height using custom T3 equations
# for (i in 1:nrow(candidates)) {
#   candidates$T3Ht[i] <- predictHeight(candidates$Species[i], candidates$DBH_cm[i], method = "customT3", DBHUnits = "cm", heightUnits = "meters")
# }
plotsWithTrees <- unique(candidates$Plot_Number)
plotLocationFilename <- "G:/R_Stuff/ONRCDroneLidar/plot_centers.xlsx"
sheetname <- "plot_centers"
plotLocations <- read_excel(plotLocationFilename, sheet = sheetname)
# we have lidar data for these plots...may not have field data for all plots
plotNumbers <- c("07", "08", "09", "10", "13", "14",
"16", "17", "18", "19", "20", "21",
"22", "23", "24", "25", "26", "27",
"28", "29", "31", "34", "36", "37",
"42", "43", "46", "47")
plotsWithTreesAndLidar <- plotNumbers[plotNumbers %in% plotsWithTrees]
# we have lidar data for these plots...may not have field data for all plots
plotNumbers <- c("7", "8", "9", "10", "13", "14",
"16", "17", "18", "19", "20", "21",
"22", "23", "24", "25", "26", "27",
"28", "29", "31", "34", "36", "37",
"42", "43", "46", "47")
plotsWithTreesAndLidar <- plotNumbers[plotNumbers %in% plotsWithTrees]
plotsWithTreesAndLidar
View(combinedTrees)
View(candidates)
outputFolder <- "E:/Backup/R_Stuff/ONRCDroneLidar"
combinedTrees <- read.csv(file = paste0(outputFolder, "/FieldTrees.csv"), stringsAsFactors = FALSE)
# predict height using custom T3 equations
for (i in 1:nrow(combinedTrees)) {
combinedTrees$T3Ht[i] <- predictHeight(combinedTrees$Species[i], combinedTrees$DBH_cm[i], method = "customT3", DBHUnits = "cm", heightUnits = "meters")
}
# filter for species, anomaly codes and field call on whether or not tree is visible from above
other <- dplyr::filter(combinedTrees, (Species != "PSME" & Species != "TSHE") | Anomaly1 != 0 | LiDAR_visible != "Y")
psme <- dplyr::filter(combinedTrees, Species == "PSME", Anomaly1 == 0, LiDAR_visible == "Y")
tshe <- dplyr::filter(combinedTrees, Species == "TSHE", Anomaly1 == 0, LiDAR_visible == "Y")
# psme and tshe are the candidate trees for matching to lidar TAOs
candidates <- rbind(psme, tshe)
# # predict height using custom T3 equations
# for (i in 1:nrow(candidates)) {
#   candidates$T3Ht[i] <- predictHeight(candidates$Species[i], candidates$DBH_cm[i], method = "customT3", DBHUnits = "cm", heightUnits = "meters")
# }
plotsWithTrees <- unique(candidates$Plot_Number)
# we have lidar data for these plots...may not have field data for all plots
plotNumbers <- c("7", "8", "9", "10", "13", "14",
"16", "17", "18", "19", "20", "21",
"22", "23", "24", "25", "26", "27",
"28", "29", "31", "34", "36", "37",
"42", "43", "46", "47")
plotsWithTreesAndLidar <- plotNumbers[plotNumbers %in% plotsWithTrees]
# need explicit folder names for each plot since some lidar collects cover more than one plot
# also folder names are horrible!!
plotFolders <- c(
"H:/T3_DroneLidar/Ba/Plot 7"
, "H:/T3_DroneLidar/Ba/Plots 8,9,36,46"
, "H:/T3_DroneLidar/Ba/Plots 8,9,36,46"
, "H:/T3_DroneLidar/Ba/Plots 10,47"
, "H:/T3_DroneLidar/Az/Plots 13,14,23,24,43"
, "H:/T3_DroneLidar/Az/Plots 13,14,23,24,43"
, "H:/T3_DroneLidar/Aa/Plots 16,31"
, "H:/T3_DroneLidar/Aa/Plots 17,18,26,27"
, "H:/T3_DroneLidar/Aa/Plots 17,18,26,27"
#  , "H:/T3_DroneLidar/Da/Plot 19"
, "H:/T3_DroneLidar/Da/Plots 20,21,22"
, "H:/T3_DroneLidar/Da/Plots 20,21,22"
, "H:/T3_DroneLidar/Da/Plots 20,21,22"
, "H:/T3_DroneLidar/Az/Plots 13,14,23,24,43"
, "H:/T3_DroneLidar/Az/Plots 13,14,23,24,43"
, "H:/T3_DroneLidar/Dz/Plots 25,42"
, "H:/T3_DroneLidar/Aa/Plots 17,18,26,27"
, "H:/T3_DroneLidar/Aa/Plots 17,18,26,27"
, "H:/T3_DroneLidar/Aa/Plots 28,29,34"
, "H:/T3_DroneLidar/Aa/Plots 28,29,34"
, "H:/T3_DroneLidar/Aa/Plots 16,31"
, "H:/T3_DroneLidar/Aa/Plots 28,29,34"
, "H:/T3_DroneLidar/Ba/Plots 8,9,36,46"
, "H:/T3_DroneLidar/Ba/Plot 37"
, "H:/T3_DroneLidar/Dz/Plots 25,42"
, "H:/T3_DroneLidar/Az/Plots 13,14,23,24,43"
, "H:/T3_DroneLidar/Ba/Plots 8,9,36,46"
, "H:/T3_DroneLidar/Ba/Plots 10,47"
)
outputFolder <- "G:/R_Stuff/ONRCDroneLidar/Adjustments"
# create FUSION tree files for the field measured trees
for (i in 1:nrow(plotsWithTreesAndLidar)) {
#   i = 1
# create FUSION tree files for the TAO objects that will be used for matching
pTrees <- candidates[candidates$Plot_Number == plotsWithTreesAndLidar[i],]
fTrees <- makeFUSIONTrees(pTrees, R = 255, G = 0, B = 255)
# get all trees for plot...needed to apply the adjustment
allpTrees <- combinedTrees[combinedTrees$Plot_Number == plotsWithTreesAndLidar[i],]
write.csv(fTrees, file = paste0(outputFolder, "/FUSIONFieldLocations_Plot_", plotsWithTreesAndLidar[i], ".csv"), row.names = FALSE, quote = TRUE)
}
# create FUSION tree files for the field measured trees
for (i in 1:length(plotsWithTreesAndLidar)) {
#   i = 1
# create FUSION tree files for the TAO objects that will be used for matching
pTrees <- candidates[candidates$Plot_Number == plotsWithTreesAndLidar[i],]
fTrees <- makeFUSIONTrees(pTrees, R = 255, G = 0, B = 255)
# get all trees for plot...needed to apply the adjustment
allpTrees <- combinedTrees[combinedTrees$Plot_Number == plotsWithTreesAndLidar[i],]
write.csv(fTrees, file = paste0(outputFolder, "/FUSIONFieldLocations_Plot_", plotsWithTreesAndLidar[i], ".csv"), row.names = FALSE, quote = TRUE)
}
